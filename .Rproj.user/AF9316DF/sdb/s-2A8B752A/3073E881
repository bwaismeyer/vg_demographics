{
    "contents" : "library(dplyr)\nlibrary(tidyr)\nlibrary(jsonlite)\nlibrary(stringr)\n\nsteamspy_data <- fromJSON(\"http://steamspy.com/api.php?request=all\")\nsp_df <- do.call(rbind, lapply(steamspy_data, as.data.frame, stringsAsFactors = FALSE))\n\nsteam_app_names <- fromJSON(\"http://api.steampowered.com/ISteamApps/GetAppList/v2\")\napp_name_df <- do.call(rbind, lapply(steam_app_names, as.data.frame, stringsAsFactors = FALSE))\nnames(app_name_df) <- c(\"appid\", \"name\")\n\nant <- paste0(head(app_name_df$appid), collapse = \",\")\nadc <- paste0(\"http://store.steampowered.com/api/appdetails/?appids=\",\n              ant)\nad1 <- paste0(\"http://store.steampowered.com/api/appdetails/?appids=\",\n              \"570\")\n\napp_name_csv <- paste0(app_name_df$appid, collapse = \",\")\napp_detail_call <- paste0(\"http://store.steampowered.com/api/appdetails/?appids=\",\n                          app_name_csv)\n\ntest <- fromJSON(ad1)\n\n# get vector and/or df of all app names\nsteam_app_names <- fromJSON(\"http://api.steampowered.com/ISteamApps/GetAppList/v2\")\napp_name_df <- do.call(rbind, lapply(steam_app_names, as.data.frame, stringsAsFactors = FALSE))\nnames(app_name_df) <- c(\"appid\", \"name\")\n\n# total query limit per 24 hours is 100,000: http://steamcommunity.com/dev/apiterms\n# possible 200 queries per 5 minutes throttling limit: https://www.reddit.com/r/Steam/comments/304dft/steam_store_api_is_there_a_throttling_limit_on/\n\n# need to run the appdetails query for each appid, but may need to space this\n# out to respect the throttling limits\n\n# 200 queries / 5 minutes * 60 minutes / 1 hour = 2400 per hour\n(200 / 5) * (60 / 1)\n# 19808 queries * 1 hour / 2400 queries ~ 8.25 hours\n19808 / 2400\n\n# quick test to see if this restriction applies\nget_app <- function(appid) {\n    if(!is.character(appid)) {\n        appid <- as.character(appid)\n    }\n    app_detail_call <- paste0(\"http://store.steampowered.com/api/appdetails/?appids=\",\n                              appid)\n    call_result <- fromJSON(app_detail_call)\n    \n    return(call_result)\n}\n\nget_all_apps <- function(appids, start_delay = 240) {\n    total_ids <- length(appids)\n    current_delay <- start_delay\n    app_list <- list()\n    \n    for(i in 1:total_ids) {\n        call_result <- try(get_app(appids[i]))\n        \n        call_fail <- typeof(call_result) != \"list\"\n        if(call_fail) {\n            message(\"Delay required...\")\n            added_secs <- 0\n            Sys.sleep(current_delay)\n            \n            call_result <- try(get_app(appids[i]))\n            call_fail <- typeof(call_result) != \"list\"\n            \n            while(call_fail) {\n                Sys.sleep(1)\n                added_secs <- added_secs + 1\n            \n                call_result <- try(get_app(appids[i]))\n                call_fail <- typeof(call_result) != \"list\"\n            }\n            \n            current_delay <- current_delay + added_secs\n            message(paste0(\"Target delay seconds = \", current_delay))\n        }\n        \n        app_list[names(call_result)] <- call_result\n        message(paste0(i, \" of \", total_ids))\n    }\n    \n    message(\"Final delay seconds = \", current_delay)\n    return(app_list)\n}\n\nraw_app_data <- get_all_apps(app_name_df$appid)\n\nsave(raw_app_data, file = \"raw_app_data.rda\")\n\n# reload as needed\nload(\"raw_app_data.rda\")\n\n# key targets in the raw app data\n# data$type\n# data$name\n# data$steam_appid\n# data$required_age\n# data$is_free\n# data$detailed_description\n# data$about_the_game\n# data$website\n# data$developers\n# data$publishers\n# data$price_overview$currency\n# data$price_overview$initial\n# data$price_overview$final\n# data$platforms$windwos\n# data$platforms$mac\n# data$platforms$linux\n# data$metacritic$score\n# data$metacritic$url\n# data$categories (df: id, description)\n# data$genres (df: id, description)\n# data$recommendations$total\n# data$achievements$total\n# data$release_date$date\nlist_to_df <- function(target) {\n    values <- list(\n        \"type\" = target[[\"type\"]],\n        \"name\" = target[[\"name\"]],\n        \"steam_appid\" = target[[\"steam_appid\"]],\n        \"required_age\" = target[[\"required_age\"]],\n        \"is_free\" = target[[\"is_free\"]],\n        \"detailed_description\" = target[[\"detailed_description\"]],\n        \"about_the_game\" = target[[\"about_the_game\"]],\n        \"website\" = target[[\"website\"]],\n        \"developers\" = paste(target[[\"developers\"]], \n                             collapse = \"---\"),\n        \"publishers\" = paste(target[[\"publishers\"]],\n                             collapse = \"---\"),\n        \"price_currency\" = target[[\"price_overview\"]][[\"currency\"]],\n        \"price_initial\" = target[[\"price_overview\"]][[\"initial\"]],\n        \"price_final\" = target[[\"price_overview\"]][[\"final\"]],\n        \"platform_windows\" = target[[\"platforms\"]][[\"windows\"]],\n        \"platform_mac\" = target[[\"platforms\"]][[\"mac\"]],\n        \"platform_linux\" = target[[\"platforms\"]][[\"linux\"]],\n        \"metacritic_score\" = target[[\"metacritic\"]][[\"score\"]],\n        \"metacritic_url\" =  target[[\"metacritic\"]][[\"url\"]],\n        \"recommendations\" = target[[\"recommendations\"]][[\"total\"]],\n        \"achievements\" = target[[\"achievements\"]][[\"total\"]],\n        \"release_date\" = target[[\"release_date\"]][[\"date\"]],\n        \"categories\" = paste(target[[\"categories\"]][[\"description\"]],\n                             collapse = \"---\"),\n        \"genres\" = paste(target[[\"genres\"]][[\"description\"]],\n                         collapse = \"---\")\n    )\n    \n    values <- data.frame(do.call(cbind, values), stringsAsFactors = FALSE)\n    \n    return(values)\n}\n\nraw_to_df <- function(raw_app_data) {\n    df_collection <- lapply(raw_app_data, function(x) list_to_df(x$data))\n    df <- dplyr::rbind_all(df_collection)\n    \n    return(df)\n}\n\napp_df <- raw_to_df(raw_app_data)\n\n# example code for grabbing basic features\nhead(sort(table(app_df$genres), decreasing = TRUE), 20)\n\n# a few of our variables are complex, representing multiple values together\n# (e.g., Action---Indie); we want to unpack these variables so that we can\n# look at the combination or the single values\n\n# we'll do this by identifying all of the unique types that can occur for \n# these variables and creating flags for each... then we'll set the flags\n# appropriately for each game\n\n# we could assume that all the unique types occur alone at least once and so\n# just grab the unique values without our separator (--) from the current\n# data... but it is unclear if this assumption is merited or not (e.g., perhaps\n# \"Indie\" never occurs alone)... alternatively, we could split all the values\n# in a column, gather these into a single vector, and then use that as our\n# list of flags...\n\n# a function that will read down a column, splitting each value as it goes\nsplit_column <- function(column, split_by) {\n    collected_splits <- c()\n    for(i in 1:length(column)) {\n        current_value <- column[i]\n        value_vector <- unlist(str_split(current_value, split_by))\n        \n        collected_splits <- c(collected_splits, value_vector)\n    }\n    \n    return(collected_splits)\n}\n\n# complex cols: developers, publishers, categories, genres\ncols_to_split <- c(\"developers\", \"publishers\", \"categories\", \"genres\")\n\n# I AM HERE - NEED TO MAKE SURE GAME IDS ARE ASSOCIATED WITH THE SPLITS AND\n# THEN NEED TO JOIN THE SOURCE DATA TO THIS TO GET THE LONG DF\n\n\n\n# BRIAN - clean up big_test to something less annoying... make this all one\n# chain... expanding all appropriate... then reflatten by making wide with\n# T/F cols...\n\nlg <- head(app_df)\nseparate(lg, cateogires, sep = \"---\")\n\ncats <- big_test %>%\n    transform(categories = strsplit(categories, \"---\")) %>%\n    unnest(categories)\n\ngens <- cats %>%\n    transform(genres = strsplit(genres, \"---\")) %>%\n    unnest(genres)",
    "created" : 1444687809429.000,
    "dirty" : false,
    "encoding" : "UTF-8",
    "folds" : "",
    "hash" : "821518526",
    "id" : "3073E881",
    "lastKnownWriteTime" : 1445277120,
    "path" : "C:/Projects/vg_demographics/scratchpad.R",
    "project_path" : "scratchpad.R",
    "properties" : {
    },
    "relative_order" : 0,
    "source_on_save" : false,
    "type" : "r_source"
}