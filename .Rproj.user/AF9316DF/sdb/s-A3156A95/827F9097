{
    "contents" : "library(dplyr)\nlibrary(tidyr)\nlibrary(jsonlite)\nlibrary(stringr)\n\nsteamspy_data <- fromJSON(\"http://steamspy.com/api.php?request=all\")\nsp_df <- do.call(rbind, lapply(steamspy_data, as.data.frame, stringsAsFactors = FALSE))\n\nsteam_app_names <- fromJSON(\"http://api.steampowered.com/ISteamApps/GetAppList/v2\")\napp_name_df <- do.call(rbind, lapply(steam_app_names, as.data.frame, stringsAsFactors = FALSE))\nnames(app_name_df) <- c(\"appid\", \"name\")\n\nant <- paste0(head(app_name_df$appid), collapse = \",\")\nadc <- paste0(\"http://store.steampowered.com/api/appdetails/?appids=\",\n              ant)\nad1 <- paste0(\"http://store.steampowered.com/api/appdetails/?appids=\",\n              \"570\")\n\napp_name_csv <- paste0(app_name_df$appid, collapse = \",\")\napp_detail_call <- paste0(\"http://store.steampowered.com/api/appdetails/?appids=\",\n                          app_name_csv)\n\ntest <- fromJSON(ad1)\n\n# get vector and/or df of all app names\nsteam_app_names <- fromJSON(\"http://api.steampowered.com/ISteamApps/GetAppList/v2\")\napp_name_df <- do.call(rbind, lapply(steam_app_names, as.data.frame, stringsAsFactors = FALSE))\nnames(app_name_df) <- c(\"appid\", \"name\")\n\n# total query limit per 24 hours is 100,000: http://steamcommunity.com/dev/apiterms\n# possible 200 queries per 5 minutes throttling limit: https://www.reddit.com/r/Steam/comments/304dft/steam_store_api_is_there_a_throttling_limit_on/\n\n# need to run the appdetails query for each appid, but may need to space this\n# out to respect the throttling limits\n\n# 200 queries / 5 minutes * 60 minutes / 1 hour = 2400 per hour\n(200 / 5) * (60 / 1)\n# 19808 queries * 1 hour / 2400 queries ~ 8.25 hours\n19808 / 2400\n\n# quick test to see if this restriction applies\nget_app <- function(appid) {\n    if(!is.character(appid)) {\n        appid <- as.character(appid)\n    }\n    app_detail_call <- paste0(\"http://store.steampowered.com/api/appdetails/?appids=\",\n                              appid)\n    call_result <- fromJSON(app_detail_call)\n    \n    return(call_result)\n}\n\nget_all_apps <- function(appids, start_delay = 240) {\n    total_ids <- length(appids)\n    current_delay <- start_delay\n    app_list <- list()\n    \n    for(i in 1:total_ids) {\n        call_result <- try(get_app(appids[i]))\n        \n        call_fail <- typeof(call_result) != \"list\"\n        if(call_fail) {\n            message(\"Delay required...\")\n            added_secs <- 0\n            Sys.sleep(current_delay)\n            \n            call_result <- try(get_app(appids[i]))\n            call_fail <- typeof(call_result) != \"list\"\n            \n            while(call_fail) {\n                Sys.sleep(1)\n                added_secs <- added_secs + 1\n            \n                call_result <- try(get_app(appids[i]))\n                call_fail <- typeof(call_result) != \"list\"\n            }\n            \n            current_delay <- current_delay + added_secs\n            message(paste0(\"Target delay seconds = \", current_delay))\n        }\n        \n        app_list[names(call_result)] <- call_result\n        message(paste0(i, \" of \", total_ids))\n    }\n    \n    message(\"Final delay seconds = \", current_delay)\n    return(app_list)\n}\n\nraw_app_data <- get_all_apps(app_name_df$appid)\n\nsave(raw_app_data, file = \"raw_app_data.rda\")\n\n# reload as needed\nload(\"raw_app_data.rda\")\n\n# key targets in the raw app data\n# data$type\n# data$name\n# data$steam_appid\n# data$required_age\n# data$is_free\n# data$detailed_description\n# data$about_the_game\n# data$website\n# data$developers\n# data$publishers\n# data$price_overview$currency\n# data$price_overview$initial\n# data$price_overview$final\n# data$platforms$windwos\n# data$platforms$mac\n# data$platforms$linux\n# data$metacritic$score\n# data$metacritic$url\n# data$categories (df: id, description)\n# data$genres (df: id, description)\n# data$recommendations$total\n# data$achievements$total\n# data$release_date$date\nlist_to_df <- function(target) {\n    values <- list(\n        \"type\" = target[[\"type\"]],\n        \"name\" = target[[\"name\"]],\n        \"steam_appid\" = target[[\"steam_appid\"]],\n        \"required_age\" = target[[\"required_age\"]],\n        \"is_free\" = target[[\"is_free\"]],\n        \"detailed_description\" = target[[\"detailed_description\"]],\n        \"about_the_game\" = target[[\"about_the_game\"]],\n        \"website\" = target[[\"website\"]],\n        \"developers\" = paste(target[[\"developers\"]], \n                             collapse = \"---\"),\n        \"publishers\" = paste(target[[\"publishers\"]],\n                             collapse = \"---\"),\n        \"price_currency\" = target[[\"price_overview\"]][[\"currency\"]],\n        \"price_initial\" = target[[\"price_overview\"]][[\"initial\"]],\n        \"price_final\" = target[[\"price_overview\"]][[\"final\"]],\n        \"platform_windows\" = target[[\"platforms\"]][[\"windows\"]],\n        \"platform_mac\" = target[[\"platforms\"]][[\"mac\"]],\n        \"platform_linux\" = target[[\"platforms\"]][[\"linux\"]],\n        \"metacritic_score\" = target[[\"metacritic\"]][[\"score\"]],\n        \"metacritic_url\" =  target[[\"metacritic\"]][[\"url\"]],\n        \"recommendations\" = target[[\"recommendations\"]][[\"total\"]],\n        \"achievements\" = target[[\"achievements\"]][[\"total\"]],\n        \"release_date\" = target[[\"release_date\"]][[\"date\"]],\n        \"categories\" = paste(target[[\"categories\"]][[\"description\"]],\n                             collapse = \"---\"),\n        \"genres\" = paste(target[[\"genres\"]][[\"description\"]],\n                         collapse = \"---\")\n    )\n    \n    values <- data.frame(do.call(cbind, values), stringsAsFactors = FALSE)\n    \n    return(values)\n}\n\nraw_to_df <- function(raw_app_data) {\n    df_collection <- lapply(raw_app_data, function(x) list_to_df(x$data))\n    df <- dplyr::rbind_all(df_collection)\n    \n    return(df)\n}\n\napp_df <- raw_to_df(raw_app_data)\n\n# example code for grabbing basic features\nhead(sort(table(app_df$genres), decreasing = TRUE), 20)\n\n# a few of our variables are complex, representing multiple values together\n# (e.g., Action---Indie); we want to unpack these variables so that we can\n# look at the combination or the single values\n\n# we'll do this by identifying all of the unique types that can occur for \n# these variables and creating flags for each... then we'll set the flags\n# appropriately for each game\n\n# we could assume that all the unique types occur alone at least once and so\n# just grab the unique values without our separator (--) from the current\n# data... but it is unclear if this assumption is merited or not (e.g., perhaps\n# \"Indie\" never occurs alone)... alternatively, we could split all the values\n# in a column, gather these into a single vector, and then use that as our\n# list of flags...\n\n# a function that will read down a column, splitting each value as it goes but\n# pairing it with its app id\nsplit_column <- function(column, split_by, id_col = NULL) {\n    collected_splits <- c()\n    \n    if(is.null(id_col)) {\n        for(i in 1:length(column)) {\n            current_value <- column[i]\n            value_vector <- unlist(str_split(current_value, split_by))\n            \n            collected_splits <- c(collected_splits, value_vector)\n        }\n    } else {\n        collected_ids <- c()\n        \n        for(i in 1:length(column)) {\n            current_value <- column[i]\n            value_vector <- unlist(str_split(current_value, split_by))\n            \n            collected_splits <- c(collected_splits, value_vector)\n            \n            current_id <- id_col[i]\n            id_vector <- rep(current_id, length(value_vector))\n            \n            collected_ids <- c(collected_ids, id_vector)\n        }\n        \n        collected_splits <- data.frame(collected_ids, collected_splits,\n                                       stringsAsFactors = FALSE)\n    }\n    \n    return(collected_splits)\n}\n\n# complex cols: developers, publishers, categories, genres\ncols_to_split <- c(\"developers\", \"publishers\", \"categories\", \"genres\")\n\n# I AM HERE:\n# cols_to_split seems to work... but there is something wrong with the\n# functions creating app_df... they are creating repeat records (e.g., \n# steam_appid == 80) in the end data frame - which means some records are\n# getting missed and some are getting double counted\n\n# TO TRY:\n# no custom list... just keep unlisting until you hit values and paste the\n# names on the way down together... apply paste to all... then can \n# test later to see which cols need splitting...\n\n# NOT unlist... for each, test... if typeof == list, then for each, test...\n# if typeof != list, then paste all values (sep = \"---\") and pass the result\n# out with the name of the path to the current item\nextract_values <- function(nested_list, collapse_string = \"---\") {\n    browser()\n    # define vector\n    value_bucket <- c()\n    # grab item names\n    item_names <- names(nested_list)\n    # loop over each item in the raw_app list\n    for(i in 1:length(nested_list)) {\n        current_item <- nested_list[[i]]\n        current_name <- item_names[[i]]\n        # test if list... if not, grab the values and pass it to the\n        # collection object, named after the current item\n        if(typeof(current_item) != \"list\") {\n            values <- paste(current_item, collapse = collapse_string)\n            value_bucket <- c(value_bucket, current_name = values)\n        } else {\n            # if list, then loop over the elements of each list recursively, \n            # passing out values when reached\n            values <- extract_values(current_item)\n            value_bucket <- c(value_bucket, values)\n        }\n    }\n    \n    # return the values extracted from the nested list - really the values\n    # passed from the current nested list mode or the final product of\n    # hybrid of grabs from direct nodes or recursive calls to the extract\n    # function\n    return(value_bucket)\n}\n\n## IF LIST IS 0, PASS NULL AND WALK AWAY BECAUSE IT'S FUCKED UP\n\ntest <- list()\nfor(i in 1:length(cols_to_split)) {\n    current_var <- cols_to_split[[i]]\n    current_col <- app_df[[current_var]]\n    id_col <- app_df$steam_appid\n    \n    current_split <- split_column(current_col, \"---\", id_col)\n    names(current_split) <- c(\"steam_appid\", paste0(\"split_\", current_var))\n    \n    test[current_var] <- list(current_split)\n}\n\njoin_test <- app_df %>%\n    left_join(test$developers) %>%\n    left_join(test$publishers) %>%\n    left_join(test$categories) %>%\n    left_join(test$genres)\n\napp_df %>%\n    filter(steam_appid == 80) %>%\n    data.frame()\n\njoin_test %>%\n    filter(steam_appid == 80) %>%\n    data.frame() %>%\n    select(steam_appid, split_publishers, split_developers, split_categories, split_genres)",
    "created" : 1445446286977.000,
    "dirty" : false,
    "encoding" : "UTF-8",
    "folds" : "",
    "hash" : "1039298022",
    "id" : "827F9097",
    "lastKnownWriteTime" : 1445298675,
    "path" : "C:/Projects/vg_demographics/scratchpad.R",
    "project_path" : "scratchpad.R",
    "properties" : {
    },
    "relative_order" : 1,
    "source_on_save" : false,
    "type" : "r_source"
}