{
    "contents" : "library(dplyr)\nlibrary(tidyr)\nlibrary(jsonlite)\nsteamspy_data <- fromJSON(\"http://steamspy.com/api.php?request=all\")\nsp_df <- do.call(rbind, lapply(steamspy_data, as.data.frame, stringsAsFactors = FALSE))\n\nsteam_app_names <- fromJSON(\"http://api.steampowered.com/ISteamApps/GetAppList/v2\")\napp_name_df <- do.call(rbind, lapply(steam_app_names, as.data.frame, stringsAsFactors = FALSE))\nnames(app_name_df) <- c(\"appid\", \"name\")\n\nant <- paste0(head(app_name_df$appid), collapse = \",\")\nadc <- paste0(\"http://store.steampowered.com/api/appdetails/?appids=\",\n              ant)\nad1 <- paste0(\"http://store.steampowered.com/api/appdetails/?appids=\",\n              \"570\")\n\napp_name_csv <- paste0(app_name_df$appid, collapse = \",\")\napp_detail_call <- paste0(\"http://store.steampowered.com/api/appdetails/?appids=\",\n                          app_name_csv)\n\ntest <- fromJSON(ad1)\n\n# get vector and/or df of all app names\nsteam_app_names <- fromJSON(\"http://api.steampowered.com/ISteamApps/GetAppList/v2\")\napp_name_df <- do.call(rbind, lapply(steam_app_names, as.data.frame, stringsAsFactors = FALSE))\nnames(app_name_df) <- c(\"appid\", \"name\")\n\n# total query limit per 24 hours is 100,000: http://steamcommunity.com/dev/apiterms\n# possible 200 queries per 5 minutes throttling limit: https://www.reddit.com/r/Steam/comments/304dft/steam_store_api_is_there_a_throttling_limit_on/\n\n# need to run the appdetails query for each appid, but may need to space this\n# out to respect the throttling limits\n\n# 200 queries / 5 minutes * 60 minutes / 1 hour = 2400 per hour\n(200 / 5) * (60 / 1)\n# 19808 queries * 1 hour / 2400 queries ~ 8.25 hours\n19808 / 2400\n\n# quick test to see if this restriction applies\nget_app <- function(appid) {\n    if(!is.character(appid)) {\n        appid <- as.character(appid)\n    }\n    app_detail_call <- paste0(\"http://store.steampowered.com/api/appdetails/?appids=\",\n                              appid)\n    call_result <- fromJSON(app_detail_call)\n    \n    return(call_result)\n}\n\nget_all_apps <- function(appids, start_delay = 240) {\n    total_ids <- length(appids)\n    current_delay <- start_delay\n    app_list <- list()\n    \n    for(i in 1:total_ids) {\n        call_result <- try(get_app(appids[i]))\n        \n        call_fail <- typeof(call_result) != \"list\"\n        if(call_fail) {\n            message(\"Delay required...\")\n            added_secs <- 0\n            Sys.sleep(current_delay)\n            \n            call_result <- try(get_app(appids[i]))\n            call_fail <- typeof(call_result) != \"list\"\n            \n            while(call_fail) {\n                Sys.sleep(1)\n                added_secs <- added_secs + 1\n            \n                call_result <- try(get_app(appids[i]))\n                call_fail <- typeof(call_result) != \"list\"\n            }\n            \n            current_delay <- current_delay + added_secs\n            message(paste0(\"Target delay seconds = \", current_delay))\n        }\n        \n        app_list[names(call_result)] <- call_result\n        message(paste0(i, \" of \", total_ids))\n    }\n    \n    message(\"Final delay seconds = \", current_delay)\n    return(app_list)\n}\n\nraw_app_data <- get_all_apps(app_name_df$appid)\n\nsave(raw_app_data, file = \"raw_app_data.rda\")\n\n# key targets in the raw app data\n# data$type\n# data$name\n# data$steam_appid\n# data$required_age\n# data$is_free\n# data$detailed_description\n# data$about_the_game\n# data$website\n# data$developers\n# data$publishers\n# data$price_overview$currency\n# data$price_overview$initial\n# data$price_overview$final\n# data$platforms$windwos\n# data$platforms$mac\n# data$platforms$linux\n# data$metacritic$score\n# data$metacritic$url\n# data$categories (df: id, description)\n# data$genres (df: id, description)\n# data$recommendations$total\n# data$achievements$total\n# data$release_date$date\nlist_to_df <- function(target) {\n    values <- list(\n        \"type\" = target[[\"type\"]],\n        \"name\" = target[[\"name\"]],\n        \"steam_appid\" = target[[\"steam_appid\"]],\n        \"required_age\" = target[[\"required_age\"]],\n        \"is_free\" = target[[\"is_free\"]],\n        \"detailed_description\" = target[[\"detailed_description\"]],\n        \"about_the_game\" = target[[\"about_the_game\"]],\n        \"website\" = target[[\"website\"]],\n        \"developers\" = paste(target[[\"developers\"]], \n                             collapse = \"---\"),\n        \"publishers\" = paste(target[[\"publishers\"]],\n                             collapse = \"---\"),\n        \"price_currency\" = target[[\"price_overview\"]][[\"currency\"]],\n        \"price_initial\" = target[[\"price_overview\"]][[\"initial\"]],\n        \"price_final\" = target[[\"price_overview\"]][[\"final\"]],\n        \"platform_windows\" = target[[\"platforms\"]][[\"windows\"]],\n        \"platform_mac\" = target[[\"platforms\"]][[\"mac\"]],\n        \"platform_linux\" = target[[\"platforms\"]][[\"linux\"]],\n        \"metacritic_score\" = target[[\"metacritic\"]][[\"score\"]],\n        \"metacritic_url\" =  target[[\"metacritic\"]][[\"url\"]],\n        \"recommendations\" = target[[\"recommendations\"]][[\"total\"]],\n        \"achievements\" = target[[\"achievements\"]][[\"total\"]],\n        \"release_date\" = target[[\"release_date\"]][[\"date\"]],\n        \"categories\" = paste(target[[\"categories\"]][[\"description\"]],\n                             collapse = \"---\"),\n        \"genres\" = paste(target[[\"genres\"]][[\"description\"]],\n                         collapse = \"---\")\n    )\n    \n    values <- data.frame(do.call(cbind, values), stringsAsFactors = FALSE)\n    \n    return(values)\n}\n\nraw_to_df <- function(raw_app_data) {\n    df_collection <- lapply(raw_app_data, function(x) list_to_df(x$data))\n    df <- dplyr::rbind_all(df_collection)\n    \n    return(df)\n}\n\nbig_test <- raw_to_df(raw_app_data)\nhead(sort(table(big_test$genres), decreasing = TRUE), 20)\n\n# a few of our variables are complex, representing multiple values together\n# (e.g., Action---Indie); we want to unpack these variables so that we can\n# look at the combination or the single values\n\n# BRIAN - clean up big_test to something less annoying... make this all one\n# chain... expanding all appropriate... then reflatten by making wide with\n# T/F cols...\n\nlg <- head(big_test)\nseparate(lg, cateogires, sep = \"---\")\n\ncats <- big_test %>%\n    transform(categories = strsplit(categories, \"---\")) %>%\n    unnest(categories)\n\ngens <- cats %>%\n    transform(genres = strsplit(genres, \"---\")) %>%\n    unnest(genres)\n\n# try recursive function?\n# - check if more nodes past current node...\n# - if yes, make vector of lists...\n# - for each node in vector...\n# - check if more nodes past current node...\n\n# - when arrive where no more nodes, check if single or mult\n#   values at current node...\n# - if single, grab and return to most recent node-vector to continue\n#   diving... save in list and name after path_to_node...\n# - if multiple, concat, grab, and return to most recent node-vector to\n#   continue diving...\n\n# - continue until no more node vectors\n\n# - values to df\n\n# - observe all collections and get all unique names...\n# - fill in all collections with missing unique names...\n# - order collections to match...\n# - rbind collections to common df\n\n# - return common df",
    "created" : 1443078231758.000,
    "dirty" : false,
    "encoding" : "UTF-8",
    "folds" : "",
    "hash" : "2722651460",
    "id" : "3F8A8FB1",
    "lastKnownWriteTime" : 1443506775,
    "path" : "C:/Projects/vg_demographics/scratchpad.R",
    "project_path" : "scratchpad.R",
    "properties" : {
    },
    "source_on_save" : false,
    "type" : "r_source"
}