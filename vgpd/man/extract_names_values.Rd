% Generated by roxygen2: do not edit by hand
% Please edit documentation in R/extract_names_values.R
\name{extract_names_values}
\alias{extract_names_values}
\title{Flattens an unpredictably nested list to a list with predictable structure.}
\usage{
extract_names_values(nested_list, layer_name = "")
}
\arguments{
\item{nested_list}{The the nested list that should be flattened to a list of
path-order-type-value nodes.}

\item{layer_name}{A character string that will be added to the front of
current element names. This is primarily used to allow the function to
build a path description as it traverses into deeper nodes.}
}
\value{
The function will return a list of lists. Each element list will
  consist of path (string), order (integer), type (string), and value
  (string) single element vectors.
}
\description{
Nested hierarchies - such as a JSON object or an R list mimicking a JSON
object - can be thought of as lists of lists. R has many solutions for
efficiently operating over and extracting contents from lists. However, most
of these solutions - especially those which seek to flatten a nested list
into a dataframe - anticipate consistency across the elements of a list.
}
\details{
These solutions break down when the content of elements is unpredictable -
such as when the number of sublists, their depth, and their contents vary
inconsistently.

\code{extract_names_values} recursively travels down all possible paths of a
nested lest - all collections of nodes that lead to content - and returns a
predictably structured list.

Specifically, the function tests whether the current element is a list. If
the element is a list, it adds it to a path description. If the element is
not a list, it is assumed to be content and all individual values present are
associated with the the path traveled to reach them, their order, and their
type.

The end result is a list of lists, where each element list now has identical
contents: a character string describing the path traversed to reach content
("path"), an integer describing the order in which a value was collected from
a piece of content ("order"), a character string describing the original type
of the collected value ("type"), and the value itself as a character string
("value").

Put another way, \code{extact_names_values} takes a hierarchy with uncertain
nesting and simplifies it to a three level hiearchy:

- the top node (the name of the full nested list itself)
-- the path-order-type-value nodes (one numbered node per path ending in a
   value in the original list)
--- path (string), order (integer), type (string), value (string)

Converting the value itself to character insures that the type will be
consistent so that the nodes can be collapsed into a long dataframe.
}
\examples{
# Load the nested Steam API data.
data(steam_app_list)

# The Steam API data is a list of nested lists, with each nested list
# representing a Steam app (e.g., PC game).

# First we run the function on a nested list with minimal nesting/content.
simple_demo <- extract_names_values(steam_app_list["5"])

# Compare that to a more complex nested list.
complex_demo <- extract_names_values(steam_app_list["50"])

# Process multiple nested lists at once.
multi_demo <- lapply(steam_app_list[1:5], extract_names_values)

# This is probably not what we want.
bad_demo <- extract_names_values(steam_app_list[1:5])

}

